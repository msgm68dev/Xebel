#!/usr/bin/python3
import os, sys, gc, time, argparse
from time import sleep as sleep
import traceback
# print("Hello")
from multiprocessing import Pool
from utils import *
from Network import Network, Path
from Traffic import Flow_property, Flow, Traffic
from Topology import Topology, Link, Switch
from mc_router import MC_Router
from routing.simple_mcp import Simple_mcp
from routing.xebel_mcp import Xebel_mcp, send_command
# Global variables
flow_properties_list = []
delay_thresholds = rate_thresholds = ()
MAIN_CONF = {}
temp_config_file = "/tmp/xebel-eval.conf.tmp"
def load_global_variables_from_config(main_conf):
    global flow_properties_list, delay_thresholds, rate_thresholds, MAIN_CONF
    MAIN_CONF.update(main_conf)
    create_file_with_path(temp_config_file)
    save_configs(MAIN_CONF, temp_config_file)
    # print("{}\n{}".format(print_dict_yml(MAIN_CONF), f"cat {temp_config_file}"))
    properties_str = main_conf['traffic_generator']['flow_properties']
    properties = comma_separated_str_to_str_tuple(properties_str)
    for prop in properties:
        words = prop.split("_")
        fp = Flow_property(name=words[0], type=words[1], min=words[2], max=words[3])
        flow_properties_list.append(fp)
    delays_thresholds_str = main_conf['onre']['metric1_thresholds']
    rate_thresholds_str = main_conf['onre']['metric2_thresholds']
    delay_thresholds = comma_separated_str_to_float_tuple(delays_thresholds_str)
    rate_thresholds = comma_separated_str_to_float_tuple(rate_thresholds_str)
    
# Xebel execution management
xebel_stopper = lambda : None # Fake initial value
def wait_for_xebel_onre_healthy(xebel_server, retries = -1, sleep_ms = 500):
    from time import sleep as sleep
    from routing.xebel_mcp import send_command
    i = retries
    while i != 0:
        try:
            healthy = send_command("healthcheck", xebel_server)
            if healthy.strip() == "OK":
                break
        except Exception as e:
            print("xebel-onre is not healthy yet: {}".format(str(e)))
        sleep(sleep_ms / 1000)
        i -= 1
def start_xebel_onre_as_child(xebel_server):
    import subprocess
    import signal
    import sys
    def signal_handler(sig, frame):
        print("\nStopping xebel-onre ...\n")
        xebel_process.terminate()  # Terminate the subprocess
        sys.exit(0)
    signal.signal(signal.SIGINT, signal_handler)
    xebel_process = subprocess.Popen(['xebel-onre', '--config-file', temp_config_file ])
    signal_caller = lambda : signal_handler(None, None)
    # return signal_handler
    return signal_caller
    # signal_handler(None, None)  # Call the signal handler to stop Xebel

# Evaluation functions


def generate_random_flowset(n_flows:int, n_ie_switches: int, flow_properties_list:list):
    flows = []
    switches = set(range(1, n_ie_switches+1))
    for i in range(n_flows):
        ie_pair = random.sample(switches, 2)
        src, dst = ie_pair
        prop_values_dict = {}
        for fp in flow_properties_list:
            prop_values_dict[fp.name] = fp.generate_random()
        f = Flow(src, dst, prop_values_dict)
        flows.append(f)
    return flows
    
def save_flowset_to_file(flows: list, filename:str, delimeter = ","):
    d = delimeter
    n_flows = len(flows)
    ful_filename = os.path.join("", filename)
    prop_names_str = f"{d} ".join([fp.name for fp in flow_properties_list])
    with open(ful_filename, mode='w') as file:
        file.write("# Generated by my TrafficGenerator !\n")
        file.write(f"#Src,   Dst, {prop_names_str}\n")
        for flow in flows:
            prop_values_str = f"{d} ".join([str(flow.property[fp.name]) for fp in flow_properties_list])
            file.write(f"{flow.src_id}{d} {flow.dst_id}{d} {prop_values_str}\n")
        file.close()
    print(f"{n_flows} flows Saved in: {ful_filename}")

def traffic_generation(conf):
    flowset_file = conf['flowset']
    n_flows = int(conf['n_flows_tgen'])
    topo_file = conf['topology']
    topo = Topology(topo_file)
    create_file_with_path(flowset_file)
    print("*** Generating random flows")
    flows = generate_random_flowset(n_flows=n_flows, 
                            n_ie_switches=topo.V, 
                            flow_properties_list=flow_properties_list)
    print("*** Refill flow metrics to fit in thresholds:")
    for f in flows:
        # f.property['delay'] = random.sample(delay_thresholds[1:-1], 1)[0]
        f.property['delay'] = find_nearest_number_in_list(delay_thresholds[1:-1], f.property['delay'])
        f.property['rate'] = int(find_nearest_number_in_list(rate_thresholds[1:-1], f.property['rate']))
    print("*** Saving flows")
    save_flowset_to_file(flows=flows, filename=flowset_file)


def linkutil(conf):
    print("\t***\tLink Utilization\t***")
    # x_onre_state = "/tmp/xebel-onre-server-binded"
    # run_shell_command_simple(f"pkill xebel-onre; echo 0 > {x_onre_state}")
    for k in conf:
        print(f"\t{k} : {conf[k]}")
    # input()
    n_flows = int(conf['n_flows'])
    flowset_file = conf['flowset']
    results_file = conf['result']
    topo_file = conf['topology']
    routing_method = conf['routing_method']
    show = is_yes(conf['per_flow_log'])
    show_detail = is_yes(conf['per_flow_log_detail'])
    debug_reject = is_yes(conf['debug_reject'])
    freecap_dir = conf['freecap_dir']
    sleep_between_flows_ms = int(conf['sleep_between_flows_ms'])
    freecap_init = float(conf['freecap_init'])
    freecap_init_x = float(conf['freecap_init_x'])
    delay_dir = conf['delay_dir']
    delay_init = float(conf['delay_init'])
    delay_grow_pcnt = float(conf['delay_grow_pcnt'])
    Config_file = conf['CONFIG_FILE']
    method_is_xebel = "xebel_mcp" in routing_method
    description = "-"
    if "description" in conf:
        description = conf["description"]
    topo = Topology(topo_file)
    traffic = Traffic(flowset_file, flow_properties_list, n_flows=n_flows)
    net = Network(topo, traffic)
    n_flows = len(net.traffic.flows)
    if freecap_init == 0:
        flow_rate_sum = sum([f.property['rate'] for f in traffic.flows])
        freecap_init = freecap_init_x * flow_rate_sum
    print("*** Initializing links' status ...")
    for link in net.topology.Links.values():
        link.OPTS['freecap_file'] = os.path.join(freecap_dir, f"{link.id[0]}-{link.id[1]}")
        link.OPTS['delay_file'] = os.path.join(delay_dir, f"{link.id[0]}-{link.id[1]}")
        link.OPTS['free'] = freecap_init
        link.OPTS['delay'] = delay_init
        link.capacity = freecap_init
        init_file_content_float(link.OPTS['freecap_file'], freecap_init)
        init_file_content_float(link.OPTS['delay_file'], delay_init)

    if method_is_xebel:
        print("*** starting xebel-onre")
        words = routing_method.split(" ")
        try:
            ip = words[1]
            port = int(words[2])
            xebel_server = (ip, port)
        except:
            raise Exception(f"cannot start xebel-onre 984563168")
        global xebel_stopper
        xebel_stopper = start_xebel_onre_as_child(xebel_server)
        wait_for_xebel_onre_healthy(xebel_server=xebel_server, retries=10, sleep_ms=1000)
        
    print("*** init routing method")
    mc_router = MC_Router(net, routing_method)
    print("*** Routing all flows")
    import statistics
    import time
    start = time.time()
    rejecteds = []
    bad_responses = 0
    # **********************************************************************************
    # **********************************************************************************
    # Main for loop: processing flows **************************************************
    for f in net.traffic.flows:
        path = mc_router.Route_delay_bw(f.src_id , f.dst_id , f.property['delay'], f.property['rate'], show=False)
        if path:
            if not path.is_suitable_for_delay_bw(f):
                bad_responses += 1
                print(f"BAD response")
                path.show(prefix = ' path: ')
                f.show(prefix = ' flow: ')
                if method_is_xebel:
                    way = tuple_to_dashedstr(tuple(path.sids))
                    command = f"path {way}"
                    resp = send_command(command, mc_router.alg.xebel_server)
                    print(f" Ask xebel: {command}")
                    print(f"   Xebel response: {resp}")
                # input("Press enter to continue...")
            # else:
            #     print(f"Good response")
            #     path.show(prefix = ' path: ')
            #     f.show(prefix = ' flow: ')
            #     input()
            for link in path.links:
                old_freecap, new_freecap = update_file_content_float_plus(link.OPTS['freecap_file'], - f.property['rate'])
                old_delay, new_delay = update_file_content_float_grow(link.OPTS['delay_file'], delay_grow_pcnt)
                link.OPTS['free'] = new_freecap
                link.OPTS['delay'] = new_delay
            if show:
                f.show(prefix="flow: ")
                path.show(prefix=" path: ")
                print(f"  delay: {path.total_delay()}, freebw: {path.total_freebw()}")

            if show_detail:
                for link in path.links:
                    print("    {}: freecap {}->{}, delay {}->{} | free {}, delay {}".format(link.id, 
                                                                    old_freecap, 
                                                                    new_freecap, 
                                                                    old_delay,
                                                                    new_delay,
                                                                    link.OPTS['free'],
                                                                    link.OPTS['delay']))
                input("Next flow: press enter ...")
        else:
            rejecteds.append(f)
            if show:
                f.show(prefix="flow: ")
                print(" REJECTED")
            # if debug_reject and method_is_xebel:
            #     print("Flow rejection debug: ")
            #     simple_mcp_router = Simple_mcp(net)
            #     f.show(prefix = "  flow: ")
            #     path2 = simple_mcp_router.route_delay_bw(f.src_id , f.dst_id , f.property['delay'], f.property['rate'])
            #     path2.show(prefix = "  simple_mcp response: path2: ")
            #     if path2:
            #         way = tuple_to_dashedstr(tuple(path2.sids))
            #         resp = send_command(f"path {way}", mc_router.alg.xebel_server)
            #         print(f"  ask xebel for path2: {resp}")

            #     input("Press enter to continue")


        sleep(sleep_between_flows_ms / 1000.0)
    # \Main for loop *******************************************************************
    # **********************************************************************************
    # **********************************************************************************
    
    # Reports:  +++++++++++++++++++++++++++++++++
    elapsed = round(time.time() - start, 2)
    print("*** calculating results: ")
    utils_byrate = [ (1-(l.OPTS['free'] / l.capacity))*100.0 \
        for l in  net.topology.Links.values()]
    utils_byrate_normalized = normalize(utils_byrate)
    utils_bydelay = [ 100 * (l.OPTS['delay'] - delay_init) / delay_init  \
        for l in  net.topology.Links.values()]
    utils_bydelay_normalized = normalize(utils_bydelay)
    caps = [l.capacity for l in  net.topology.Links.values()]
    avg_cap = statistics.mean(caps)
    avg_util_rate = round(statistics.mean(utils_byrate), 2)
    std_util_rate = round(statistics.stdev(utils_byrate), 2)
    std_util_rate_norm = round(100 * statistics.stdev(utils_byrate_normalized), 2)
    avg_util_delay = round(statistics.mean(utils_bydelay), 2)
    std_util_delay = round(statistics.stdev(utils_bydelay), 2)
    std_util_delay_norm = round(100 * statistics.stdev(utils_bydelay_normalized), 2)
    avg_flow_delay = statistics.mean([f.property['delay'] for f in net.traffic.flows])
    avg_flow_rate = statistics.mean([f.property['rate'] for f in net.traffic.flows])
    nrej = len(rejecteds)
    rej_rate = round((100.0 * nrej) / n_flows, 2)
    first_rej = -1
    if nrej > 0:
        first_rej = net.traffic.flows.index(rejecteds[0])
    # try:
    # with open(results_file, mode='a') as f:
        # f.write("\n{0:<30}{1:<10}{2:<10}{3:<10}{4:<10}{5:<10}{6:<10}{7:<10}{8:<10}{9:<5}\n".format( \
        #         "Algorithm", "avg_cap", "avg_%util", "std_%util", "%reject", 
        #         "1stRej", "time", "topo", "traffic", "n_flows"))
        # f.write("{0:<30}{1:<10}{2:<10}{3:<10}{4:<10}{5:<10}{6:<10}{7:<10}{8:<10}{9:<5}\n".format( \
        #         routing_method, avg_cap, avg_util_rate,  
        #         std_util_rate, rej_rate, first_rej, elapsed, 
        #         net.topology.name, net.traffic.name, n_flows))
        # f.write(logstr)
        # f.close()
    logstr = ""
    logstr += f"routing_method, {routing_method}, "
    logstr += f"**rej_rate, {rej_rate} , "
    logstr += f"std_util_rate_norm(LB), {std_util_rate_norm}, "
    logstr += f"std_util_delay_norm, {std_util_delay_norm}, "
    logstr += f"first_rej, {first_rej}, "
    logstr += f"**bad_responses, {bad_responses}, "
    logstr += f"std_util_rate, {std_util_rate}, "
    logstr += f"std_util_delay, {std_util_delay}, "
    # logstr += f"avg_util_rate, {avg_util_rate}, "
    # logstr += f"avg_util_delay, {avg_util_delay}, "
    logstr += f"|, "
    logstr += f"n_flows, {n_flows}, "
    logstr += f"sleep_between_flows_ms, {sleep_between_flows_ms}, "
    logstr += f"freecap_init_x, {freecap_init_x}, "
    logstr += f"delay_grow_pcnt, {delay_grow_pcnt}, "
    logstr += f"delay_init, {delay_init}, "
    logstr += f"freecap_init, {avg_cap}, "
    logstr += f"|, "
    # logstr += f"avg_flow_delay, {avg_flow_delay}, "
    # logstr += f"avg_flow_rate, {avg_flow_rate}, "
    # logstr += f"net.topology.name, {net.topology.name}, "
    # logstr += f"net.traffic.name, {net.traffic.name}, "
    logstr += f"elapsed, {elapsed}, "
    logstr += f"date, {datetime.now()}, "
    logstr += f"descr, {description}, "
    if method_is_xebel:
        logstr += f"|, "
        bw_thresholds = tuple_to_dashedstr(comma_separated_str_to_float_tuple(MAIN_CONF['onre']['metric2_thresholds']))
        delay_thresholds = tuple_to_dashedstr(comma_separated_str_to_float_tuple(MAIN_CONF['onre']['metric1_thresholds']))
        logstr += f"bw_thresholds, {bw_thresholds}"
        logstr += f"delay_thresholds, {delay_thresholds}"

    logstr += "\n"
    log_into(logstr, results_file, timestamp= False, print_it= True)    
    print("*** Results appended to: \ncat " + results_file)
    xebel_stopper()

# Main 
def Evaluator(Function, Config):
    load_global_variables_from_config(Config)
    def linkutil_call():
        try:
            linkutil(Config['link_utilization'])
        except Exception as e:
            print(" * * * * * * ** * Errrorrrr in linkutil ::: {}".format(str(e)))
            traceback.print_exc()
            xebel_stopper()
    if Function == "all":
        traffic_generation(Config['traffic_generator'])
        linkutil_call()
    elif Function == "tgen":
        traffic_generation(Config['traffic_generator'])
    elif Function == "linkutil":
        linkutil_call()
    else:
        raise Exception(f"Unknown --function {Function}")

if __name__ == "__main__":
    argc = len(sys.argv)
    argv = sys.argv
    config_filename = "xebel-eval.conf"
    # Define command-line switches:
    parser = argparse.ArgumentParser()
    _instead = "(instead of the value in the config file)"
    # Define the --config-file switch
    parser.add_argument("--config-file", help=f"specify the configuration file")
    parser.add_argument("--function", help=f"specify the evaluation function (default: all)")
    # single configs:
    parser.add_argument("--n_flows", type=str, help=f"specify n_flows for linkutil ")
    parser.add_argument("--n_flows_tgen", type=str, help=f"specify n_flows_tgen for tgen ")
    parser.add_argument("--flowset", type=str, help=f"specify flowset file to be generated and used {_instead}")
    parser.add_argument("--ways_file", type=str, help=f"specify ways_file address for xebel-onre {_instead}")
    parser.add_argument("--equations_file", type=str, help=f"specify equations_file address for xebel-onre {_instead}")
    parser.add_argument("--freecap_init", type=float, help=f"specify freecap_init value for linkutil test {_instead}")
    parser.add_argument("--freecap_init_x", type=float, help=f"specify x for auto freecap_init (x * flow_rates_sum) {_instead}")
    parser.add_argument("--delay_init", type=float, help=f"specify delay_init value for linkutil test {_instead}")
    parser.add_argument("--delay_grow_pcnt", type=float, help=f"specify delay_grow_pcnt value for linkutil test {_instead}")
    parser.add_argument("--routing_method", type=str, help=f"specify routing_method for linkutil test {_instead}")
    parser.add_argument("--sleep_between_flows_ms", type=str, help=f"specify sleep_between_flows_ms value for linkutil test {_instead}")
    parser.add_argument("--debug_reject", type=str, help=f"specify debug_reject value for linkutil test {_instead}")
    parser.add_argument("--per_flow_log", type=str, help=f"specify per_flow_log value for linkutil test {_instead}")
    parser.add_argument("--per_flow_log_detail", type=str, help=f"specify per_flow_log_detail value for linkutil test {_instead}")
    parser.add_argument("--metric1_thresholds", type=str, help=f"Threshlods for metric1 (delay) {_instead}")
    parser.add_argument("--metric2_thresholds", type=str, help=f"Threshlods for metric2 (bw) {_instead}")
    parser.add_argument("--description", type=str, help=f"Extra edscription for a xebel-eval run")
    # In switch haye jadid ro varede conf kon
    parser.add_argument("args", nargs="*", help=f"any arguments without switches")
    args = parser.parse_args()
    Config_file = args.config_file
    Function = args.function or "all"
    # Overwriting configs:
    N_flows_tgen = args.n_flows_tgen or None
    N_flows = args.n_flows or None
    Flowset = args.flowset or None
    Ways_file = args.ways_file or None
    Equations_file = args.equations_file or None
    Freecap_init = args.freecap_init or None
    Freecap_init_x = args.freecap_init_x or None
    Delay_init = args.delay_init or None
    Delay_grow_pcnt = args.delay_grow_pcnt or None
    Routing_method = args.routing_method or None
    Sleep_between_flows_ms = args.sleep_between_flows_ms or None
    Debug_reject = args.debug_reject or None
    Per_flow_log = args.per_flow_log or None
    Per_flow_log_detail = args.per_flow_log_detail or None
    Metric2_thresholds = args.metric2_thresholds or None
    Metric1_thresholds = args.metric1_thresholds or None
    Description = args.description or None
    current_dir = os.getcwd()
    print(f"Here: {current_dir}")
    if not Config_file:
        if os.path.exists(current_dir + "/" + config_filename):
            Config_file = os.path.join(current_dir, config_filename)
        elif os.path.exists(f"/root/configs/{config_filename}"):
            Config_file = f"/root/configs/{config_filename}"
        else:
            print(f"No config file ({config_filename}) found!")
    print(f"Using config file: {Config_file}")
    Config = load_configs(Config_file)
    Config['link_utilization'].update({"CONFIG_FILE" : Config_file})
    # for k in Config:
    #     input(f"{k} = {Config[k]}\n")
    if N_flows_tgen:
        Config['traffic_generator'].update({"n_flows_tgen" : N_flows_tgen})
    if N_flows:
        Config['link_utilization'].update({"n_flows" : N_flows})
    if Flowset :
        Config['traffic_generator'].update({"flowset" : Flowset})
        Config['link_utilization'].update({"flowset" : Flowset})
        Config['evalBatch'].update({"flowset" : Flowset})
    if Ways_file :
        Config['onre'].update({"ways_file" : Ways_file})
    if Equations_file :
        Config['onre'].update({"equations_file" : Equations_file})
    if Freecap_init :
        Config['link_utilization'].update({"freecap_init" : Freecap_init})
    if Freecap_init_x :
        Config['link_utilization'].update({"freecap_init_x" : Freecap_init_x})
    if Delay_init :
        Config['link_utilization'].update({"delay_init" : Delay_init})
    if Delay_grow_pcnt :
        Config['link_utilization'].update({"delay_grow_pcnt" : Delay_grow_pcnt})
    if Routing_method :
        Config['link_utilization'].update({"routing_method" : Routing_method})
    if Sleep_between_flows_ms :
        Config['link_utilization'].update({"sleep_between_flows_ms" : Sleep_between_flows_ms})
    if Debug_reject :
        Config['link_utilization'].update({"debug_reject" : Debug_reject})
    if Per_flow_log :
        Config['link_utilization'].update({"per_flow_log" : Per_flow_log})
    if Per_flow_log_detail :
        Config['link_utilization'].update({"per_flow_log_detail" : Per_flow_log_detail})
    if Metric1_thresholds :
        Config['onre'].update({"metric1_thresholds" : Metric1_thresholds})
    if Metric2_thresholds :
        Config['onre'].update({"metric2_thresholds" : Metric2_thresholds})
    if Description :
        Config['traffic_generator'].update({"description" : Description})
        Config['link_utilization'].update({"description" : Description})
        Config['evalBatch'].update({"description" : Description})

    Evaluator(Function, Config)
